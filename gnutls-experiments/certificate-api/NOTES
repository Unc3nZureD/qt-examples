[20:47] <richmoore1> anyone up for talking some api design thoughts?
[20:48] <thiago> yeah
[20:48] <richmoore1> okay, i have a prototype for creating and signing certificates and certificate signing requests
[20:49] <richmoore1> unlike qsslcertificate etc. these are mutable since they are all about creating them and building what you want
[20:49] <thiago> yup
[20:49] <thiago> did you split the CRQ too?
[20:49] <richmoore1> split?
[20:50] <richmoore1> you build it with this https://gitorious.org/qt-examples/qt-examples/blobs/master/gnutls-experiments/create-certificate/certificaterequest.h
[20:50] <richmoore1> finally you call sign() then you export it
[20:50] <thiago> let's just go over the workflow:
[20:51] <richmoore1> okay
[20:51] <thiago> how do you create the CRQ?
[20:51] <richmoore1> 1. create the empty crq
[20:51] <thiago> that needs to output the CRQ and private key
[20:51] <richmoore1> 2. add stuff (key, name entries etc.)
[20:51] <richmoore1> 3. sign
[20:51] <richmoore1> 4. export
[20:51] <thiago> sign with what?
[20:52] <richmoore1> it can be either a key generated by the class, or an existing key if you are renewing a certificate
[20:53] <thiago> how do you load the private key?
[20:53] <thiago> QSslKey enough?
[20:53] <richmoore1> at the moment the code only supports creating a new private key, but loading one is easy
[20:53] <richmoore1> right now i'm not using any of the qssl classes in this prototype
[20:53] --> giucam_ has joined this channel (~giulio@adsl-ull-186-207.49-151.net24.it).
[20:54] <richmoore1> i've done it using gnutls rather than openssl
[20:54] <thiago> this code wouldn't end up in QtNetwork, true
[20:54] <richmoore1> yeah, i'm thinking of an addon
[20:54] <thiago> but can you get the necessary data of the key from a QSslKey?
[20:54] <richmoore1> yes, that has all i need
[20:54] <thiago> except the ability to generate a new key
[20:55] <richmoore1> yes, and the ability to handle key passphrases
[20:55] <thiago> for decrypting a key?
[20:55] <richmoore1> yes
[20:55] <thiago> that's the key loader
[20:56] <thiago> let's say you add an API that loads a key with a passphrase to QSslKey
[20:56] <thiago> and you add an API that generates a new key in your addon
[20:56] <richmoore1> yes, that is probably doable
[20:56] <richmoore1> i can also create a new key and return a QSslKey without any real problem
[20:57] <-- giucam has left this server (Ping timeout: 260 seconds).
[20:57] <thiago> in your certificate request class, you should take a QSslKey object
[20:57] <richmoore1> yes, that is possible
[20:57] <thiago> the only drawback is a roundtrip through OpenSSL internals
[20:58] <thiago> anyway, after you sign, you can't change the object anymore, right?
[20:58] <richmoore1> this kind of code should never be performance critical anyway
[20:58] <richmoore1> yes, once signed it should not be modified
[20:59] <thiago> so I'd say that the sign() function should return the immutable CRQ, ready to be sent to the CA
[20:59] <thiago> as opposed to being a void sign() function
[20:59] <richmoore1> yeah, that's along the lines of what i'm thinking. so we'd have a CRQBuilder and a CertBuilder
[20:59] <thiago> in turn, that means we need a better name than sign(), as that's a verb in the imperative
[20:59] <thiago> something like signed() or signedRequest()
[21:00] <richmoore1> i like signed() because then i can use the same name for both crq and cert
[21:00] <thiago> ok
[21:00] <thiago> we might need a noun suffix there anyway... but let's come back to it later
[21:01] <thiago> the object that it returns must provide a way to get the PEM and DER forms, so they can be uploaded
[21:01] <thiago> and it must be usable by the CA
[21:01] <richmoore1> yep, that's a fundamental requirement for it to be useful
[21:01] <thiago> before that, how so you make a self-signed cert?
[21:02] <richmoore1> you sign with the key of the crq
[21:02] <thiago> isn't that what we've just done?
[21:02] <richmoore1> at the moment that's actually all the codebase can do (easy to fix)
[21:02] <richmoore1> no, we signed the crq not the cert
[21:02] <richmoore1> we get the crq then:
[21:03] <richmoore1> 1) check it looks sane
[21:03] <richmoore1> 2)
[21:03] <richmoore1> 2) add extensions etc. like keyids, purpose etc.
[21:03] --> richardmg2 has joined this channel (~richard@cm-84.208.230.46.getinternet.no).
[21:03] <richmoore1> 3) set the dates, constraints etc.
[21:03] <richmoore1> 4) sign
[21:03] <richmoore1> 5) export
[21:03] <thiago> understood
[21:04] <thiago> for a CA, we'd load the CA's cert and key, then sign the CRQ, producing a cert
[21:04] <thiago> correct?
[21:04] <richmoore1> correct
[21:04] <thiago> for a self signed, I need to load the key, but no cert. Correct?
[21:05] <richmoore1> not quite, you use the cert your currently creating so the process is actually the same
[21:05] <thiago> how can I load the cert that I haven't created yet?
[21:05] --> ci_ has joined this channel (~ci@host86-144-26-180.range86-144.btcentralplus.com).
[21:06] <richmoore1> you reference it directly and it uses fields like the subject of the 'in-progress' cert to define the issuer of the result
[21:06] <thiago> are CRQ and Cert the same structure, except that CRQ aren't signed by a CA?
[21:06] <richmoore1> no
[21:06] <-- mkfnx has left this server (Ping timeout: 246 seconds).
[21:06] <thiago> 1st step: create private key
[21:06] <thiago> 2nd step: create CRQ
[21:06] <-- noirr has left this server (Ping timeout: 260 seconds).
[21:06] <thiago> 3rd: sign CRQ with private key
[21:07] <thiago> what is the output of the 3rd step called?
[21:07] <richmoore1>  the private key there is the one of the person creating the crq, until the request is signed it's not finished
[21:08] <richmoore1> the output of that is a certificate signing request
[21:08] <thiago> ok, CSR
[21:09] <thiago> if I want to self-sign, how do I load a certificate?
[21:09] <richmoore1> you load the csr, then add the extensions etc. and finally sign it using your incomplete certificate and your private key
[21:10] <thiago> I have my private key from step #1
[21:10] <thiago> where do I get my (incomplete) certificate from?
[21:10] <thiago> is that the output of the 2nd step?
[21:11] <richmoore1> yes, you copy various fields from the request
[21:12] <thiago> where to?
[21:12] <richmoore1> into the certificate you're making - https://gitorious.org/qt-examples/qt-examples/blobs/master/gnutls-experiments/create-certificate/certificate_gnutls.cpp#line237 this is where i do it
[21:13] <richmoore1> basically it copies the subject info and the public key
[21:13] <thiago> ok
[21:13] <thiago> let me see if I got it now:
[21:13] <thiago> step 1: create a new private key; output: QSslKey
[21:14] <thiago> step 2: create the new certificate-to-be-signed; output: new class like QSslCertificate, but mutable
[21:14] <richmoore1> no step 1.5: create a certificate signing request
[21:14] <thiago> step 3: create the CSR by calling signed()
[21:15] <thiago> how can you create the request to sign before you create the stuff-to-be-signed?
[21:15] <richmoore1> okay, i think i jumped in too early
[21:16] <richmoore1> step 2: the class at this point is much cut-down compared to a full certificate
[21:16] <richmoore1> it is similar however, it's basically just the subject information and a public key
[21:16] <thiago> step 4: either a QSslCertificate or the mutable QSslCertificate-like object into the signer, along with a private key
[21:16] <thiago> s/:/: load/
[21:17] <thiago> output: QSslCertificate (signed)
[21:17] <richmoore1> yes, that's right
[21:18] <richmoore1> so, i think it should reuse qsslkey, qsslcertificate
[21:19] <richmoore1> add a new qsslcertificatesigningrequest
[21:19] <thiago> me too
[21:19] <thiago> I'm actually wondering about that
[21:19] <thiago> sounds to me that we can merge the CSR into the mutable QSslCertificate class
[21:19] <richmoore1> and have mutable certificatebuilder and certificatesigningrequest builder classes (or something similar)
[21:19] <thiago> once you sign it, it's a CSR
[21:19] <richmoore1> yes
[21:19] <thiago> if you modify anything, it must either print a warning or throw the signature away
[21:20] <richmoore1> a certificate has lots more options of things it can contain than a csr, and has an independent format version number etc.
[21:21] <thiago> you've lost me again
[21:21] <thiago> are those fields independent of the cert's own signature?
[21:22] <richmoore1> okay, i'm thinking we can't merge the csr and the cert building thing because they have lots of fields that are possible in one but not the other, but also fields that exist in both like the version which differ - certs are generally v3 whereas csrs are v1
[21:23] <thiago> can you change things in the CSR?
[21:23] <thiago> I thought it was an immutable thing that was sent to the CA
[21:23] <richmoore1> up until it is signed you can
[21:23] <thiago> wait
[21:23] <thiago> I'm mixing terms up
[21:23] <thiago> we have the certificate-in-progress, before it is signed by a private key
[21:23] <thiago> that's where one sets things like CN
[21:24] <richmoore1> that's more set by the csr-in-progress
[21:24] <thiago> this is too complex to the user
[21:24] <thiago> I want to create a certificate
[21:24] <thiago> so I configure my certificate before signing it myself
[21:25] <thiago> once I do sign, can I still modify things in it, without invalidating the output I sent the CA?
[21:25] <richmoore1> no
[21:26] <thiago> once signed, there's only one path which is to get it signed by the CA
[21:26] <richmoore1> the csr is a bundle of stuff you specify and sign so you can pass it to a 3rd party. you can also set those things directly on a cert when you're creating it
[21:27] <-- APTX has left this server (Read error: Connection reset by peer).
[21:27] <thiago> my suggestion is that you make the mutable QSslCertificate-like class derive from QSslCertificate or return one on need (operator QSslCertificate() const)
[21:28] --> APTX has joined this channel (APTX@unaffiliated/aptx).
[21:28] <thiago> that way, the API to sign the request simply takes a QSslCertificate and private key
[21:29] <richmoore1> i might be able to do something like that perhaps. i'm not sure 
[21:30] <thiago> anyway, the signer class may need to add fields, like the expiration date, right?
[21:31] <richmoore1> yes, it definitely will need add a whole bunch
[21:31] <thiago> ok, you answered my next question: it's a whole bunch
[21:31] <thiago> we probably need a method like reset() in that class that clears the fields-to-be-added
[21:32] <thiago> goes back to just the CA cert and private key
[21:32] <thiago> so you can sign a new certificate
[21:32] <thiago> if you don't call it, it will reuse the fields from the last signing
[21:32] <thiago> would that be acceptable?
[21:33] <-- ottoshmidt has left this server (Quit: Leaving).
[21:33] <-- plfiorini has left this server (Ping timeout: 260 seconds).
[21:34] <richmoore1> i'm dubious, it sounds like it might be an api where it's easy to accidentally transfer info from one request to another by mistake, but i like the general idea of having something where you can set the fixed items then reuse them
[21:34] <thiago> I'm thinking of the API
[21:35] <thiago> we'd have something like CertificateSigner(const QSslCertificate &signingCertificate, const QSslKey &signingKey)
[21:35] <richmoore1> yes, that part i like
[21:35] <thiago> then QSslCertificate signed(const CertificateBuilder &builder, const CertificateFields &fieldsToAdd);
[21:36] <thiago> the other option is to remove the CertificateFields struct and merge it into CertificateSigner
[21:36] <thiago> that's the one with reset()
[21:36] <richmoore1> i think the certificatesigner is a better place for it, the complexity of the stuff you add is significant
[21:37] <thiago> is it normal for CAs to add the same new fields to all certs they sign? like the purpose?
[21:38] <richmoore1> they'll usually have a few profiles for different stuff - web server certs, code signing certs etc.
[21:38] <thiago> can we say that the "profile" is this CertificateSigner object?
[21:39] <thiago> i.e., if I were to process a batch of new requests to be signed, would it make sense to reuse the same object?
[21:39] <-- lildeimos has left this server (Read error: Operation timed out).
[21:40] <richmoore1> from an efficiency point of view, then yes. from a defensive coding point of view no.
[21:40] <thiago> why? what fields do I as a CA set that are specific to the cert being signed?
[21:41] <richmoore1> the main ones are subjectaltnames, the purpose flags, the dates, and the permission flags
[21:42] <richmoore1> having a reset() method is totally doable
[21:42] <thiago> really? I thought that the names were set by the originator
[21:42] <thiago> dates I agree
[21:42] <richmoore1> in theory it is the originator, but actually that's no what happens
[21:42] <thiago> the originator does set the CN, right?
[21:43] <richmoore1> eg. if you request *.foo.com the CA will add a SAN of foo.com to give it the behavior that users expect
[21:44] <richmoore1> yes, CN is from the originator
[21:44] <thiago> that sounds really weird
[21:44] <richmoore1> it is
[21:44] <thiago> can one certificate be signed by more than one CA?
[21:44] <richmoore1> yes, but don't go there, it's a can of worms
[21:44] <thiago> ok
[21:45] <thiago> the reason I'm asking is: what happens if the originator has SAN?
[21:45] <-- tmcguire has left this server (Ping timeout: 264 seconds).
[21:45] <thiago> can the CA add more SAN?
[21:45] <richmoore1> no, they can only add an additional signature
[21:45] <thiago> so you can add fields if the originator didn't add them, right?
[21:46] <richmoore1> the ca can yes
[21:46] --> plfiorini has joined this channel (~plfiorini@93-39-250-109.ip78.fastwebnet.it).
[21:46] <thiago> so I suppose that if the originator added expiration dates, the CA wouldn't be able to sign
[21:46] <thiago> (or wouldn't want to)
[21:46] <-- smokex has left this server (Quit: Quazaa 0.1.r0 (2012-11-18)).
[21:46] <richmoore1> those fields don't exist in a CSR so can't be added. csrs can however contain extensions such as SAN or extended key usage
[21:47] <thiago> ok
[21:48] --> smokex has joined this channel (~smokex@122.150.67.220).
[21:48] <thiago> I get the point about defensive coding
[21:49] <thiago> it's rather dangerous to have the new SAN remain in the object after signing
[21:49] <-- bhughes has left this server (Quit: bhughes).
[21:49] <richmoore1> yes, and signing is an expensive operation anyway, so forcing a fresh instance seems like a reasonable option
[21:50] <thiago> what if we invert the arguments: you create the signing from the subject to be signed
[21:50] <thiago> then we have signed(const QSslCertificate &signingCert, const QSslKey &signingKey)
[21:51] <richmoore1> that works, in fact it's pretty much what my current prototype does
[21:51] <-- ZapB has left this server (Ping timeout: 246 seconds).
[21:53] <thiago> do we want to support multiple CA signing?
[21:53] <-- vapula has left this server (Remote host closed the connection).
[21:53] --> lildeimos has joined this channel (~lildeimos@95.236.26.25).
[21:53] <richmoore1> i don't think so - the only time i've ever even heard of it was the diginotar thing 
[21:54] <richmoore1> if we want to support it then step 1 would be me understanding it which currently i don't fully
[21:54] <thiago> isn't it the same as giving the cert already signed by one entity to another?
[21:55] <richmoore1> i think so, but since i've not sat down and checked the details i wouldn't commit - ssl has lots of special cases 
